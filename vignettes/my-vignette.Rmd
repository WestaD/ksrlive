---
title: "Introduction to ksrlive"
author: "Westa Domanova"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

## Load data

This package contains a part of the phosphoproteomics data from 
[Humphrey *et al.*, Cell Metabolism, 2013](http://dx.doi.org/10.1016/j.cmet.2013.04.010).   

```{r, phospho-data}
# library(ksrlive)
devtools::load_all("~/Desktop/ksrlive") # replace this with top line at the end
data(datalist)
#head(data_kin)
```

Also included in this package is an integrated database of site specific kinase 
substrate relationships. The databases used were: 
[PhosphositePLUS](http://www.phosphosite.org/), downloaded 2014/06/23, 
[PhosphoELM](http://phospho.elm.eu.org/) release 9.0, 
[PhosphoPOINT](http://kinase.bioinformatics.tw) 04/2014 and 
[Human Protein Reference Database](http://www.hprd.org/) release 9.

```{r, ssksr-data}
data(phosphonetwork)
#head(phosphonetwork.df)
```

## Create kinase substrate lists
Kinase substrate lists using the ssKSR database have to be created for further 
clustering. Kinases known to belong to one family can be combined into one list
if a family list is given. Further, setting the exclusive argument to TRUE will 
guarantee that only phosphosites appearing once will be included. This is 
important for the initial clustering. 

```{r, kinase-substrate-lists}
# create identifier for substrate in database
test_db <- do.call(paste, 
c(phosphonetwork.df[ ,c("SUB_ACC_ID.human", "MODSITE_SEQ.human")],
sep = "_"))
test_db <- data.frame(substrate = test_db, 
kinase = phosphonetwork.df[ ,"KIN_ACC_ID.human"], 
stringsAsFactors = FALSE)

# create identifier for substrate in data
nam_map <- do.call(paste, 
c(data_kin[, c("Uniprot.human", "Motif.human")], sep = "_"))
ind_map <- match(test_db[ ,"substrate"], nam_map)
test_db <- data.frame(test_db, data_name = rownames(data_kin)[ind_map],
stringsAsFactors = FALSE)
kin_data <- KSR.list(test_db[, c(3, 2)]) # first column has to be substrate id, second kinase id

# Akt1 and Akt2 belong to the same kinase family, combine their substrates into one list and name the list after the first family member
fam <- list(akt = c("P31749", "P31751"))
kin_data_fam <- KSR.list(test_db[, c(3, 2)], kinasefamilies = fam)

# only include phosphosites appearing once
kin_data_fam_exc <- KSR.list(test_db[, c(3, 2)], kinasefamilies = fam,
exclusive = TRUE)
```

## Cluster exclusive and all substrates
Data dependent clustering can be performed using the function kinclust. The data 
has to be in the format where rows correspond to observations and columns to samples
 (e.g. time points). It is recommended that the clustering is run with nboot set 
 to at least 10000. Given a cluster object the clustering can be performed in 
 parallel. 
```{r clustering, cache = TRUE, message = FALSE, comment = FALSE}
scaled_ind <- grep("scaled", colnames(data_kin))

# clustering using exclusive substrates
kin_clust <- kinclust(data = data_kin[ , scaled_ind],
                      kin_list = kin_data_fam_exc,
                      nboot = 1000,
                      method.dist = "euclidean",
                      method.hclust = "average")

# clustering using all substrates
kin_clust_all <- kinclust(data = data_kin[ , scaled_ind],
                          kin_list = kin_data_fam,
                          nboot = 1000,
                          method.dist = "euclidean",
                          method.hclust = "average")

# example using parallel computing
library(parallel)
corenumber <- detectCores()
corenumber
cl <- makeCluster(corenumber)
kin_clust_all <- kinclust(data = data_kin[ , scaled_ind],
                          kin_list = kin_data_fam,
                          cl = cl,
                          nboot = 10000,
                          method.dist = "euclidean",
                          method.hclust = "average")
stopCluster(cl)
```

A dendrogram and line graphs of the clustering can be displayed. (Additional packages needed)
```{r clustering-result, eval = TRUE}
library(ggplot2)
library(reshape2)
library(pvclust)

timelab <- sapply(strsplit(colnames(kin_clust[["data"]][[1]]), split = "_"), "[[", 1)
```
```{r plot-dendr, fig.width = 7, fig.height = 6}
# plot dendrogram from pvclust result
plot(kin_clust[[1]][[1]])
pvrect(kin_clust[[1]][[1]], alpha = kin_clust[["most_stable"]][[1]])
```
```{r plot-lines, fig.width = 7, fig.height = 6}
plotdata <- data.frame(time = c(1:ncol(kin_clust[["data"]][[1]])), t(kin_clust[["data"]][[1]]))
plotdata_long <- melt(plotdata, id = "time")  # convert to long format
clust <- kin_clust[["clustering"]][[1]]
clust_long <- as.factor(unlist(lapply(clust, rep, ncol(kin_clust[["data"]][[1]]))))
plotdata_long <- cbind(plotdata_long, cluster = clust_long)
ggplot(plotdata_long, 
            aes(x = time, y = value, colour = cluster, group = variable)) + 
      scale_color_manual(values = c("lightblue", "red")) +
      xlab("Time") +
      ylab("scaled logfc") +
      scale_x_discrete(limit = c(1:9),
                     labels = timelab) +
      geom_line()
```

## Integrate exclusive clustering and all substrate clustering
The tightest cluster for a kinase formed the core substrates. The core substrates were also tested for differential regulation using a 1.5 fold change cut off in two out of three replicates. In a second step clustering was performed using all available substrates for a kinase and the cluster containing the core substrates was taken as the characteristic temporal response for the kinase. The cut off p value for the clusters was set to 0.05. Differentially regulated substrates in the characteristic temporal response formed the automatic training set of the kinase.
```{r integrate-clustering}
expand_all_list <- clust.expand(kin_clust, kin_clust_all)
```
----------------------------------------------------------------------


Vignettes are long form documentation commonly included in packages. Because they are part of the distribution of the package, they need to be as compact as possible. The `html_vignette` output type provides a custom style sheet (and tweaks some options) to ensure that the resulting html is as small as possible. The `html_vignette` format:

- Never uses retina figures
- Has a smaller default figure size
- Uses a custom CSS stylesheet instead of the default Twitter Bootstrap style

## Vignette Info

Note the various macros within the `vignette` setion of the metadata block above. These are required in order to instruct R how to build the vignette. Note that you should change the `title` field and the `\VignetteIndexEntry` to match the title of your vignette.

## Styles

The `html_vignette` template includes a basic CSS theme. To override this theme you can specify your own CSS in the document metadata as follows:

    output: 
      rmarkdown::html_vignette:
        css: mystyles.css

You can enable figure captions by `fig_caption: yes` in YAML:

    output:
      rmarkdown::html_vignette:
        fig_caption: yes

Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**.

## More Examples

You can write math expressions, e.g. $Y = X\beta + \epsilon$, footnotes^[A footnote here.], and tables, e.g. using `knitr::kable()`.

```{r, echo=FALSE, results='asis'}
knitr::kable(head(mtcars, 10))
```

Also a quote using `>`:

> "He who gives up [code] safety for [code] speed deserves neither."
([via](https://twitter.com/hadleywickham/status/504368538874703872))

