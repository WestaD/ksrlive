---
title: "Introduction to ksrlive"
author: "Westa Domanova"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

Using this package you can combine known site specific kinase substrate relationships with dynamic experimental data and determine active kinases and their substrates.

## Data in this package

This package contains a part of the phosphoproteomics data from 
[Humphrey *et al.*, Cell Metabolism, 2013](http://dx.doi.org/10.1016/j.cmet.2013.04.010).   

```{r, phospho-data}
# library(ksrlive)
devtools::load_all("~/Desktop/ksrlive") # replace this with top line at the end
data(datalist)
#head(data_kin)
```

Also included in this package is an integrated database of site specific kinase 
substrate relationships. The databases used were: 
[PhosphositePLUS](http://www.phosphosite.org/), downloaded 2014/06/23, 
[PhosphoELM](http://phospho.elm.eu.org/) release 9.0, 
[PhosphoPOINT](http://kinase.bioinformatics.tw) 04/2014 and 
[Human Protein Reference Database](http://www.hprd.org/) release 9.

```{r, ssksr-data}
data(phosphonetwork)
#head(phosphonetwork.df)
```

## Create kinase substrate lists
Kinase substrate lists using the ssKSR database have to be created for further 
clustering. Kinases known to belong to one family can be combined into one list
if a family list is given. Further, setting the exclusive argument to TRUE will 
guarantee that only phosphosites appearing once will be included. This is 
important for the initial clustering. 

```{r, kinase-substrate-lists}
# create identifier for substrate in database
test_db <- do.call(paste, 
c(phosphonetwork.df[ ,c("SUB_ACC_ID.human", "MODSITE_SEQ.human")],
sep = "_"))
test_db <- data.frame(substrate = test_db, 
kinase = phosphonetwork.df[ ,"KIN_ACC_ID.human"], 
stringsAsFactors = FALSE)

# create identifier for substrate in data
nam_map <- do.call(paste, 
c(data_kin[, c("Uniprot.human", "Motif.human")], sep = "_"))
ind_map <- match(test_db[ ,"substrate"], nam_map)
test_db <- data.frame(test_db, data_name = rownames(data_kin)[ind_map],
stringsAsFactors = FALSE)
kin_data <- KSR.list(test_db[, c(3, 2)]) # first column has to be substrate id, second kinase id

# Akt1 and Akt2 belong to the same kinase family, combine their substrates into one list and name the list after the first family member
fam <- list(akt = c("P31749", "P31751"))
kin_data_fam <- KSR.list(test_db[, c(3, 2)], kinasefamilies = fam)

# only include phosphosites appearing once
kin_data_fam_exc <- KSR.list(test_db[, c(3, 2)], kinasefamilies = fam,
exclusive = TRUE)
```

## Cluster exclusive and all substrates
Data dependent clustering can be performed using the function kinclust. The tightest cluster for a kinase forms the core substrates. In a second step clustering using all available substrates for a kinase can be performed. The data has to be in the format where rows correspond to observations and columns to samples (e.g. time points). It is recommended that the clustering is run with nboot set to at least 10000. Given a cluster object the clustering can be performed in parallel. 
```{r clustering, cache = TRUE, message = FALSE, results = "hide"}
scaled_ind <- grep("scaled", colnames(data_kin))

# clustering using exclusive substrates
kin_clust <- kinclust(data = data_kin[ , scaled_ind],
                      kin_list = kin_data_fam_exc,
                      nboot = 1000,
                      method.dist = "euclidean",
                      method.hclust = "average")

# only need to cluster what was clustered using exclusive list
only <- match(names(kin_data_fam_exc), names(kin_data_fam))
# clustering using all substrates
kin_clust_all <- kinclust(data = data_kin[ , scaled_ind],
                          kin_list = kin_data_fam[only],
                          nboot = 1000,
                          method.dist = "euclidean",
                          method.hclust = "average")

# example using parallel computing
#library(parallel)
#corenumber <- detectCores()
#corenumber
#cl <- makeCluster(corenumber)
#kin_clust_all <- kinclust(data = data_kin[ , scaled_ind],
#                          kin_list = kin_data_fam,
#                          cl = cl,
#                          nboot = 100,
#                          method.dist = "euclidean",
#                          method.hclust = "average",
#                          init.rand = TRUE,
#                          iseed = 21)
#stopCluster(cl)
```

A dendrogram and line graphs of the clustering can be displayed. (Additional packages needed)
```{r clustering-result, eval = TRUE}
library(ggplot2)
library(reshape2)
library(pvclust)

timelab <- sapply(strsplit(colnames(kin_clust[["data"]][[1]]), split = "_"), "[[", 1)
```
```{r plot-dendr, fig.width = 7, fig.height = 6}
# plot dendrogram from pvclust result
plot(kin_clust[[1]][[1]])
pvrect(kin_clust[[1]][[1]], alpha = kin_clust[["most_stable"]][[1]])
```
```{r plot-lines, fig.width = 7, fig.height = 6}
plotdata <- data.frame(time = c(1:ncol(kin_clust[["data"]][[1]])), t(kin_clust[["data"]][[1]]))
plotdata_long <- melt(plotdata, id = "time")  # convert to long format
clust <- kin_clust[["clustering"]][[1]]
clust_long <- as.factor(unlist(lapply(clust, rep, ncol(kin_clust[["data"]][[1]]))))
plotdata_long <- cbind(plotdata_long, cluster = clust_long)
ggplot(plotdata_long, 
            aes(x = time, y = value, colour = cluster, group = variable)) + 
      scale_color_manual(values = c("lightblue", "red", "purple", "green")) +
      xlab("Time") +
      ylab("scaled logfc") +
      scale_x_discrete(limit = c(1:9),
                     labels = timelab) +
      geom_line()
```

## Integrate exclusive clustering and all substrate clustering
To integrate the clustering using exclusive and all substrates the function clust.expand 
finds which cluster the core substrates from the exclusive clustering fall in the 
clustering performed using all substrates. The cluster containing the core substrates
forms the characteristic temporal response of the kinase. A cut off p value for the clustering can be set and it is recommended to provide a list of differentially regulated substrates. This list will be used to test core substrates for differential regulation. 

```{r integrate-clustering}
expand_all_list <- clust.expand(kin_clust, kin_clust_all)
expand_all <- expand_all_list[[1]]
```

Plot final clustering
```{r plot-cluster, fig.width = 7, fig.height = 6}
i = 1
library(ggplot2)
library(reshape2)
plotdata <- data.frame(time = c(1:length(scaled_ind)), t(data_kin[names(expand_all[[i]]), scaled_ind]))
plotdata_long <- melt(plotdata, id = "time")  # convert to long format
clust <- expand_all[[i]]
clust_long <- as.factor(unlist(lapply(clust, rep, length(scaled_ind))))
plotdata_long <- cbind(plotdata_long, cluster = clust_long)
ggplot(plotdata_long, 
            aes(x = time, y = value, colour = cluster, group = variable)) + 
      scale_color_manual(values = c("lightblue", "red", "purple", "green")) +
      xlab("Time") +
      ylab("scaled logfc") +
      scale_x_discrete(limit = c(1:9),
                     labels = timelab) +
      geom_line()
```

This will plot the cluster mean and standard deviation as a ribbon. 

```{r ribbon-plot, fig.width = 7, fig.height = 6}
plotstat <- data.frame(time = c(1:length(scaled_ind)), t(data_kin[names(expand_all[[i]])[which(expand_all[[i]] == 1)], scaled_ind]))
plotstat$mean <- apply(plotstat[ , 2:ncol(plotstat)], 1, mean)
plotstat$sd <- apply(plotstat[ , 2:ncol(plotstat)], 1, sd)
colors <- c("orange")
ggplot(plotstat, aes(x = time, y = mean)) + 
  geom_line(size = 1, color = colors[1]) + 
      xlab("Time") +
      ylab("scaled logfc") +
      scale_x_discrete(limit = c(1:9),
                     labels = timelab) +
   geom_ribbon(aes(ymax = mean + sd, ymin = mean - sd), color = colors[1], fill = colors[1], alpha = 0.5)
```